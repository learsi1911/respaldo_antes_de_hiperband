# -*- coding: utf-8 -*-
"""
Created on Mon Aug  9 16:36:21 2021

@author: 20210595
"""

# -*- coding: utf-8 -*-
"""
Created on Sun Jul 25 00:58:52 2021

@author: 20210595
"""

# from . import space_autogenerated
# positionsClassifiers = space_autogenerated.positionsClassifiers
# positionsPreprocessingTechniques = space_autogenerated.positionsPreprocessingTechniques
# positions = space_autogenerated.positions
# float_int_positions = space_autogenerated.float_int_positions
from space_autogenerated import positionsPreprocessingTechniques, positionsModels, positions, float_int_positions

#Pipeline
from sklearn.pipeline import make_pipeline, Pipeline

#pre-processing techniques

from sklearn.impute import SimpleImputer
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.preprocessing import Normalizer

# statsmodels
from statsmodels.tsa.ar_model import AutoReg
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.statespace.sarimax import SARIMAX
from statsmodels.tsa.holtwinters import ExponentialSmoothing
from statsmodels.tsa.holtwinters import Holt
from statsmodels.tsa.holtwinters import SimpleExpSmoothing
from statsmodels.tsa.statespace.exponential_smoothing import ExponentialSmoothing
from statsmodels.tsa.exponential_smoothing.ets import ETSModel
from statsmodels.tsa.statespace.dynamic_factor import DynamicFactor
from statsmodels.tsa.statespace.dynamic_factor_mq import DynamicFactorMQ
from statsmodels.tsa.vector_ar.var_model import VAR
from statsmodels.tsa.statespace.varmax import VARMAX
from statsmodels.tsa.vector_ar.svar_model import SVAR
from statsmodels.tsa.vector_ar.vecm import VECM
from statsmodels.tsa.statespace.structural import UnobservedComponents

#example_int_to_string = int_to_string(3, rbf = 0, kernel2 = 1)

class ChoosePipeline(object):
    def __init__(self, positionsModels = positionsModels, positions = positions, position_int_float = float_int_positions, positionsPreprocessingTechniques= positionsPreprocessingTechniques):
        self.position_int_float = position_int_float
        self.positions = positions
        self.positionsPreprocessingTechniques = positionsPreprocessingTechniques
        self.positionsModels = positionsModels
        
    def __call__(self, x, serie):
        
        #NewSerie = values.reshape((len(values), 1))
        _positions = self.positions
        build_vec = self._build_vector(x)
        list_index_techniques_to_use = []
        for i in self.positionsPreprocessingTechniques:
            if x[i] > 15:
                list_index_techniques_to_use.append(i)    
        
        lista_index_final_prepross = []
        for i in range(len(positionsPreprocessingTechniques)):
            for j in list_index_techniques_to_use:
                if positionsPreprocessingTechniques[i]==j:
                    lista_index_final_prepross.append(i)

        preprocessPipeline = self._preprossessing_techniques(lista_index_final_prepross, build_vec)
        #return preprocessPipeline
        
        valueIndicesModels = [x[i] for i in self.positionsModels]
        max_value = max(valueIndicesModels)
        max_index = valueIndicesModels.index(max_value)
        indexModel = self.positionsModels[max_index]

        #print(positionModelNew)
        # valueIndicesModels = [x[i] for i in self.positionsModels]
        # max_value = max(valueIndicesModels)
        # max_index = valueIndicesModels.index(max_value)
        # indexModel = self.positionsModels[max_index]
        # #The last index is the classifier
        # list_index_techniques_to_use.append(indexModel)
        # lista_index_final = []
        # for i in range(len(_positions)):
        #     for j in list_index_techniques_to_use:
        #         if positions[i][1]==j:
        #             lista_index_final.append(i)
        try: 
            PipelineTSFinal = self._techniques(indexModel, build_vec, preprocessPipeline, serie=serie)
        except:
            PipelineTSFinal = 'invalid'
        # PipelineToUse = self._techniques(indexModel, build_vec, preprocessPipeline, serie=serie)
        return preprocessPipeline, PipelineTSFinal
        # return PipelineTSFinal
        
        
    
    def _build_vector(self, x):
        _vector_int_float = x.copy() 
        _vector_pos_copy = self.position_int_float.copy()
        for i in range(len(_vector_int_float)):
            if _vector_pos_copy[i][1] == 'int':
                _vector_int_float[i] = int(round(_vector_int_float[i]))
        return _vector_int_float
    
    def _preprossessing_techniques(self, lista_index_final_prepross, build_vec):
        x=build_vec
        estimators = [('SimpleImputer', SimpleImputer(strategy = self._int_to_string(round(x[1]), mean=0, median=1, most_frequent=2), 
                                                      fill_value=x[2]))
                      ]
        new_estimators = [estimators[i] for i in lista_index_final_prepross]
        preprossPipeline = Pipeline(new_estimators)
        return preprossPipeline
    
    def _techniques(self, indexModel, build_vec, preprocessPipeline, serie):
        x=build_vec
        if indexModel == self.positions[len(self.positionsPreprocessingTechniques)][1]:
            pipelineModelTS = Pipeline([('AutoReg', AutoReg(preprocessPipeline.fit(serie).transform(serie),
                                          lags=round(x[4]),
                                          trend=self._int_to_string(round(x[5]), n=0, c=1, t=2, ct=3)
                                          ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+1][1]:
            pipelineModelTS = Pipeline([('ARIMA', ARIMA(preprocessPipeline.fit(serie).transform(serie),
                                      order=(round(x[7]),round(x[8]),round(x[9])),
                                      trend=self._int_to_string(round(x[10]), n=0, c=1, t=2, ct=3),
                                      enforce_stationarity=self._int_to_bool(round(x[11])),
                                      enforce_invertibility=self._int_to_bool(round(x[12])),
                                      concentrate_scale=self._int_to_bool(round(x[13]))
                                      ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+2][1]:
            pipelineModelTS = Pipeline([('SARIMAX', SARIMAX(preprocessPipeline.fit(serie).transform(serie),
                                          order=(round(x[15]),round(x[16]),round(x[17])),
                                          trend=self._int_to_string(round(x[18]), n=0, c=1, t=2, ct=3),
                                          enforce_stationarity=self._int_to_bool(round(x[19])),
                                          enforce_invertibility=self._int_to_bool(round(x[20]))
                                          ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+3][1]:
            pipelineModelTS = Pipeline([('ExponentialSmoothing', ExponentialSmoothing(preprocessPipeline.fit(serie).transform(serie),
                                                                  trend=self._int_to_string(round(x[22]), add=0, mul=1, additive=2, multiplicative=3),
                                                                  damped_trend=self._int_to_bool(round(x[23])), 
                                                                  seasonal=self._int_to_string(round(x[24]), add=0, mul=1, additive=2, multiplicative=3), 
                                                                  initialization_method=self._int_to_string(round(x[25]), estimated=0, heuristic=1, known=2), 
                                                                  initial_level=x[26], 
                                                                  initial_trend=x[27]
                                                                  ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+4][1]:
            pipelineModelTS = Pipeline([('Holt', Holt(preprocessPipeline.fit(serie).transform(serie),
                                    exponential=self._int_to_bool(round(x[29])), 
                                    damped_trend=self._int_to_bool(round(x[30])), 
                                    initialization_method=self._int_to_string(round(x[31]), estimated=0, heuristic=1, known=2), 
                                    initial_level=x[32], 
                                    initial_trend=x[33]
                                    ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+5][1]:
            pipelineModelTS = Pipeline([('SimpleExpSmoothing', SimpleExpSmoothing(preprocessPipeline.fit(serie).transform(serie),
                                                                initialization_method=self._int_to_string(round(x[35]), estimated=0, heuristic=1, known=2),
                                                                initial_level=x[36]
                                                                ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+6][1]:
            pipelineModelTS = Pipeline([('ETSModel', ETSModel(preprocessPipeline.fit(serie).transform(serie),
                                            error=self._int_to_string(round(x[38]), add=0, mul=1),
                                            trend=self._int_to_string(round(x[39]), add=0, mul=1),
                                            damped_trend=self._int_to_bool(round(x[40])),
                                            seasonal=self._int_to_string(round(x[41]), add=0, mul=1),
                                            seasonal_periods=round(x[42]),
                                            initialization_method=self._int_to_string(round(x[43]), estimated=0, heuristic=1, known=2),
                                            initial_level=x[44],
                                            initial_trend=x[45]
                                            ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+7][1]:
            pipelineModelTS = Pipeline([('DynamicFactor', DynamicFactor(preprocessPipeline.fit(serie).transform(serie), 
                                                      k_factors=round(x[47]), 
                                                      factor_order=round(x[48]), 
                                                      error_cov_type=self._int_to_string(round(x[49]), scalar=0, diagonal=1, unstructured=2)
                                                      ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+8][1]:
            pipelineModelTS = Pipeline([('DynamicFactorMQ', DynamicFactorMQ(preprocessPipeline.fit(serie).transform(serie), 
                                                          k_endog_monthly =round(x[51]), 
                                                          factors=round(x[52]), 
                                                          factor_orders=round(x[53]), 
                                                          factor_multiplicities=round(x[54]), 
                                                          idiosyncratic_ar1=self._int_to_bool(round(x[55])), 
                                                          standardize=self._int_to_bool(round(x[56])), 
                                                          init_t0=self._int_to_bool(round(x[57])) 
                                                          ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+9][1]:
            pipelineModelTS = Pipeline([('VAR', VAR(preprocessPipeline.fit(serie).transform(serie)))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+10][1]:
            pipelineModelTS = Pipeline([('VARMAX', VARMAX(preprocessPipeline.fit(serie).transform(serie),
                                        order=(round(x[60]),round(x[61])),
                                        trend=self._int_to_string(round(x[62]), n=0, c=1, t=2, ct=3),
                                        error_cov_type=self._int_to_string(round(x[63]), diagonal=0, unstructured=1),
                                        measurement_error=self._int_to_bool(round(x[64])),
                                        enforce_stationarity=self._int_to_bool(round(x[65])),
                                        enforce_invertibility=self._int_to_bool(round(x[66]))
                                        ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+11][1]:
            pipelineModelTS = Pipeline([('SVAR', SVAR(preprocessPipeline.fit(serie).transform(serie),
                                    svar_typestr = self._int_to_string(round(x[68]), A=0, B=1, AB=2),
                                    ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+12][1]:
            pipelineModelTS = Pipeline([('VECM', VECM(preprocessPipeline.fit(serie).transform(serie),
                                    k_ar_diff=round(x[70]),
                                    coint_rank=round(x[71]),
                                    deterministic=self._int_to_string(round(x[72]), nc=0, co=1, ci=2, lo=3, li=4)
                                    ))])
        elif indexModel == self.positions[len(self.positionsPreprocessingTechniques)+13][1]:
            pipelineModelTS = Pipeline([('UnobservedComponents', UnobservedComponents(preprocessPipeline.fit(serie).transform(serie),
                                                                    level=self._int_to_bool(round(x[74])),
                                                                    trend=self._int_to_bool(round(x[75])),
                                                                    seasonal=round(x[76]),
                                                                    cycle=self._int_to_bool(round(x[77])),
                                                                    autoregressive=round(x[78]),
                                                                    irregular=self._int_to_bool(round(x[79])),
                                                                    stochastic_level=self._int_to_bool(round(x[80])),
                                                                    stochastic_trend=self._int_to_bool(round(x[81])),
                                                                    stochastic_seasonal=self._int_to_bool(round(x[82])),
                                                                    stochastic_cycle=self._int_to_bool(round(x[83])),
                                                                    damped_cycle=self._int_to_bool(round(x[84])),
                                                                    use_exact_diffuse=self._int_to_bool(round(x[85]))
                                                                    ))])
        return pipelineModelTS
    
    def _int_to_string(self, value, **kwargs):
        for element in kwargs:
            if kwargs[element] == value:
                return element 
            
    def _int_to_bool(self, value):
            if value == 1:
                return True
            else:
                return False       
  
# from numpy import genfromtxt
# examples = genfromtxt('prueba.csv', delimiter=',') 
# from pandas import read_csv   
# import pandas as pd
# series = read_csv('ibm-common-stock-closing-prices.csv', header=0, index_col=0)
# NewSerie = series.values
# prueba = ChoosePipeline()
# # x_va = prueba(examples[6], NewSerie)

# nueva = list()
# for i in examples:
#     x_va = prueba(i, NewSerie)
#     nueva.append(x_va)
    
if __name__=='__main__':      
    from numpy import genfromtxt
    examples = genfromtxt('prueba.csv', delimiter=',') 
    from pandas import read_csv   
    import pandas as pd
    series = read_csv('ibm-common-stock-closing-prices.csv', header=0, index_col=0)
    NewSerie = series.values
    prueba = ChoosePipeline()
    #x_va = prueba(examples[1], NewSerie)
    
    nueva = list()
    for i in examples:
        x_va = prueba(i, NewSerie)
        nueva.append(x_va)

# from sklearn import datasets

# # import some data to play with
# iris = datasets.load_iris()
# X = iris.data  # we only take the first two features.
# y = iris.target


# def _build_vector(x):
#     _vector_int_float = x.copy() 
#     _vector_pos_copy = float_int_positions.copy()
#     for i in range(len(_vector_int_float)):
#         if _vector_pos_copy[i][1] == 'int':
#             _vector_int_float[i] = int(round(_vector_int_float[i]))
#     return _vector_int_float
    
# x = examples[1]
# build_vec = _build_vector(x)
# list_index_techniques_to_use = []
# for i in positionsPreprocessingTechniques:
#     if round(x[i]) == 1:
#         list_index_techniques_to_use.append(i)
# valueIndicesClassifiers = [x[i] for i in positionsClassifiers]
# max_value = max(valueIndicesClassifiers)
# max_index = valueIndicesClassifiers.index(max_value)
# indexClassifier = positionsClassifiers[max_index]
# #The last index is the classifier
# list_index_techniques_to_use.append(indexClassifier)

# auxiliar = []
# for i in range(len(positions)):
#     for j in list_index_techniques_to_use:
#         if positions[i][1]==j:
#             auxiliar.append(i)
